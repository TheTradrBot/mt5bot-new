Here's the complete, copy-paste ready Replit prompt:

---

```
You are an elite trading bot developer.  Your mission is to fix this MT5 trading bot so it replicates the exact backtest performance while being 100% FTMO 10K challenge compliant. 

## GOAL
Replicate backtest results:  1135 trades, 78% win rate, +1066R in 2024 - but on a $10,000 FTMO challenge account without EVER breaching any rule.

## BACKTEST PERFORMANCE TO REPLICATE
Period: Jan 2024 - Dec 2024
Total Trades: 1135 across 34 assets
Win Rate: 78.0%
Total R: +1066.40R
Avg R/Trade: +0.94R
Exit Breakdown:  TP1+Trail 15%, TP2 56. 2%, TP3 21.8%, SL 7%

Top performers:  SPX500, NAS100, AUD_NZD, GBP_JPY, USD_JPY, XAU_USD, CAD_JPY, CHF_JPY, GBP_CAD, EUR_GBP

## FTMO 10K CHALLENGE RULES (NEVER BREACH)
- Account Size: $10,000
- Max Daily Loss: 5% ($500) from day start balance
- Max Total Drawdown: 10% ($1,000) from initial balance  
- Phase 1 Target:  +10% ($1,000)
- Phase 2 Target: +5% ($500)
- No minimum trading days

## ROOT CAUSE OF CURRENT PROBLEM
The backtest enters trades IMMEDIATELY when confluence is met because it evaluates bar-by-bar and price is already AT the entry level. But the live bot calculates entry prices from structure/fib levels that may be FAR from current price, places pending orders that never fill, and misses all the trades the backtest would have taken.

## COMPLETE FIX REQUIRED

### STEP 1: Create new file `ftmo_config.py`

```python
"""
FTMO 10K Challenge Configuration
Optimized settings to pass challenge while replicating backtest performance.
"""

from dataclasses import dataclass
from typing import Dict

@dataclass
class FTMO10KConfig:
    """FTMO 10K Challenge optimized configuration."""
    
    # === ACCOUNT SETTINGS ===
    account_size: float = 10000.0
    account_currency: str = "USD"
    
    # === FTMO RULES (HARD LIMITS - NEVER BREACH) ===
    max_daily_loss_pct: float = 5.0  # $500
    max_total_drawdown_pct: float = 10.0  # $1,000
    phase1_target_pct: float = 10.0  # $1,000
    phase2_target_pct: float = 5.0  # $500
    
    # === SAFETY BUFFERS (Stop BEFORE breach) ===
    daily_loss_warning_pct:  float = 2.5  # $250 - reduce risk
    daily_loss_reduce_pct: float = 3.5  # $350 - minimal risk only
    daily_loss_halt_pct: float = 4.2  # $420 - stop trading
    total_dd_warning_pct: float = 5.0  # $500 - reduce risk
    total_dd_reduce_pct: float = 7.0  # $700 - minimal risk
    total_dd_halt_pct: float = 8.5  # $850 - stop trading
    
    # === POSITION SIZING (Conservative for 10K) ===
    risk_per_trade_pct:  float = 0.75  # $75 max risk per trade
    risk_per_trade_reduced_pct: float = 0.4  # $40 when in warning zone
    risk_per_trade_minimal_pct: float = 0.2  # $20 when in danger zone
    max_cumulative_risk_pct: float = 2.5  # $250 total open risk
    
    # === TRADE LIMITS ===
    max_concurrent_trades: int = 4  # Max 4 open positions
    max_pending_orders:  int = 5  # Max 5 pending orders
    max_trades_per_day: int = 8  # Max 8 trades per day
    max_trades_per_symbol: int = 1  # Only 1 trade per symbol
    
    # === ENTRY OPTIMIZATION (Match Backtest) ===
    max_entry_distance_r: float = 1.0  # Entry must be within 1R of current price
    immediate_entry_r: float = 0.15  # Use market order if within 0.15R
    pending_order_expiry_hours: int = 6  # Cancel pending after 6 hours
    
    # === STOP LOSS SETTINGS ===
    min_sl_pips: float = 8. 0  # Minimum 8 pips SL
    max_sl_pips: float = 100.0  # Maximum 100 pips SL
    min_sl_atr_ratio:  float = 0.4  # Minimum 0.4 ATR
    max_sl_atr_ratio: float = 2.0  # Maximum 2.0 ATR
    
    # === TAKE PROFIT SETTINGS (Lock profits fast) ===
    tp1_r_multiple: float = 1.0  # TP1 at 1R
    tp2_r_multiple:  float = 2.0  # TP2 at 2R
    tp3_r_multiple: float = 3.0  # TP3 at 3R
    
    # === PARTIAL CLOSE PERCENTAGES ===
    tp1_close_pct: float = 0.40  # Close 40% at TP1
    tp2_close_pct: float = 0.35  # Close 35% at TP2
    tp3_close_pct: float = 0.25  # Close 25% at TP3
    
    # === BREAKEVEN SETTINGS ===
    move_sl_to_be_after_tp1: bool = True
    be_buffer_pips: float = 2.0  # Move SL to entry + 2 pips
    
    # === ULTRA SAFE MODE (When close to target) ===
    ultra_safe_profit_threshold_pct: float = 8.0  # Enable at +$800
    ultra_safe_risk_pct: float = 0.25  # Only $25 risk in ultra-safe
    ultra_safe_max_trades: int = 2  # Max 2 trades in ultra-safe
    
    # === CONFLUENCE SETTINGS (Same as backtest) ===
    min_confluence_score: int = 4  # 4/7 minimum
    min_quality_factors: int = 1  # At least 1 quality factor
    require_rr_flag: bool = True  # Must have valid R: R
    require_confirmation: bool = False  # H4 confirmation optional
    
    # === PROTECTION LOOP ===
    protection_interval_sec: float = 20.0  # Check every 20 seconds
    
    def get_risk_pct(self, daily_loss_pct: float, total_dd_pct: float) -> float:
        """Get adjusted risk percentage based on current drawdown."""
        if daily_loss_pct >= self.daily_loss_halt_pct or total_dd_pct >= self.total_dd_halt_pct:
            return 0.0
        elif daily_loss_pct >= self.daily_loss_reduce_pct or total_dd_pct >= self.total_dd_reduce_pct:
            return self.risk_per_trade_minimal_pct
        elif daily_loss_pct >= self.daily_loss_warning_pct or total_dd_pct >= self.total_dd_warning_pct:
            return self.risk_per_trade_reduced_pct
        else: 
            return self.risk_per_trade_pct
    
    def get_max_trades(self, profit_pct: float) -> int:
        """Get max concurrent trades based on profit level."""
        if profit_pct >= self.ultra_safe_profit_threshold_pct:
            return self.ultra_safe_max_trades
        return self.max_concurrent_trades


# Global config instance
FTMO_CONFIG = FTMO10KConfig()

# Pip sizes by instrument type
PIP_SIZES = {
    "forex_jpy": 0.01,
    "forex_standard": 0.0001,
    "xauusd": 0.1,
    "xagusd":  0.01,
    "indices": 1.0,
    "crypto": 1.0,
}

def get_pip_size(symbol: str) -> float:
    """Get pip size for a symbol."""
    s = symbol.upper()
    if "JPY" in s:
        return PIP_SIZES["forex_jpy"]
    elif "XAU" in s or "GOLD" in s:
        return PIP_SIZES["xauusd"]
    elif "XAG" in s or "SILVER" in s:
        return PIP_SIZES["xagusd"]
    elif any(idx in s for idx in ["US30", "US500", "NAS100", "SPX500", "DAX", "USTEC", "DJ30"]):
        return PIP_SIZES["indices"]
    elif any(crypto in s for crypto in ["BTC", "ETH", "LTC"]):
        return PIP_SIZES["crypto"]
    else:
        return PIP_SIZES["forex_standard"]
```

### STEP 2: Update `main_live_bot.py` - Replace the `scan_symbol` method entirely

Find the `scan_symbol` method and replace it with this: 

```python
def scan_symbol(self, symbol: str) -> Optional[Dict]:
    """
    Scan a single symbol for trade setup.
    
    MATCHES BACKTEST LOGIC EXACTLY:
    1. Get HTF trends (M/W/D)
    2. Pick direction from bias
    3. Compute confluence flags
    4. Check for active setup
    5. NEW: Validate entry is reachable from current price
    6. NEW: Validate SL is appropriate
    
    Returns trade setup dict if signal is active AND tradeable, None otherwise.
    """
    from ftmo_config import FTMO_CONFIG, get_pip_size
    
    # Skip if symbol not available on broker
    if symbol not in self.symbol_map:
        log.debug(f"[{symbol}] Not available on this broker, skipping")
        return None
    
    broker_symbol = self.symbol_map[symbol]
    log.info(f"[{symbol}] Scanning (broker: {broker_symbol})...")
    
    # Check if we already have a position on this symbol
    if self.check_existing_position(broker_symbol):
        log.info(f"[{symbol}] Already in position, skipping")
        return None
    
    # Check if we already have a pending setup for this symbol
    if symbol in self.pending_setups:
        existing = self.pending_setups[symbol]
        if existing.status == "pending":
            log.info(f"[{symbol}] Already have pending setup, skipping")
            return None
    
    # Get candle data
    data = self.get_candle_data(symbol)
    
    if not data["daily"] or len(data["daily"]) < 50:
        log.warning(f"[{symbol}] Insufficient daily data ({len(data. get('daily', []))} candles)")
        return None
    
    if not data["weekly"] or len(data["weekly"]) < 10:
        log.warning(f"[{symbol}] Insufficient weekly data")
        return None
    
    monthly_candles = data["monthly"] if data["monthly"] else []
    weekly_candles = data["weekly"]
    daily_candles = data["daily"]
    h4_candles = data["h4"] if data["h4"] else daily_candles[-20:]
    
    # === STEP 1:  Determine HTF Bias (Same as backtest) ===
    mn_trend = _infer_trend(monthly_candles) if monthly_candles else "mixed"
    wk_trend = _infer_trend(weekly_candles) if weekly_candles else "mixed"
    d_trend = _infer_trend(daily_candles) if daily_candles else "mixed"
    
    direction, _, _ = _pick_direction_from_bias(mn_trend, wk_trend, d_trend)
    
    # === STEP 2: Compute Confluence (Same as backtest) ===
    flags, notes, trade_levels = compute_confluence(
        monthly_candles,
        weekly_candles,
        daily_candles,
        h4_candles,
        direction,
        self.params,
    )
    
    entry, sl, tp1, tp2, tp3, tp4, tp5 = trade_levels
    
    # === STEP 3: Calculate Confluence Score (Same as backtest) ===
    confluence_score = sum(1 for v in flags. values() if v)
    
    has_confirmation = flags.get("confirmation", False)
    has_rr = flags.get("rr", False)
    has_location = flags.get("location", False)
    has_fib = flags.get("fib", False)
    has_liquidity = flags.get("liquidity", False)
    has_structure = flags.get("structure", False)
    has_htf_bias = flags.get("htf_bias", False)
    
    quality_factors = sum([has_location, has_fib, has_liquidity, has_structure, has_htf_bias])
    
    # === STEP 4:  Determine Status (Same as backtest) ===
    if has_rr and confluence_score >= FTMO_CONFIG.min_confluence_score and quality_factors >= FTMO_CONFIG.min_quality_factors:
        status = "active"
    elif confluence_score >= FTMO_CONFIG.min_confluence_score:
        status = "watching"
    else:
        status = "scan_only"
    
    log.info(f"[{symbol}] {direction. upper()} | Conf: {confluence_score}/7 | Quality: {quality_factors} | Status: {status}")
    
    # Log individual flags for debugging
    for pillar, is_met in flags.items():
        marker = "✓" if is_met else "✗"
        note = notes. get(pillar, "")[:50]
        log.debug(f"  [{marker}] {pillar}: {note}")
    
    # Not an active signal
    if status != "active":
        return None
    
    # === STEP 5: Validate Entry/SL/TP Levels ===
    if entry is None or sl is None or tp1 is None:
        log.warning(f"[{symbol}] Missing entry/SL/TP levels")
        return None
    
    risk = abs(entry - sl)
    if risk <= 0:
        log.warning(f"[{symbol}] Invalid risk: entry={entry:. 5f}, sl={sl:.5f}")
        return None
    
    # === STEP 6: GET CURRENT PRICE - Critical for matching backtest ===
    tick = self.mt5.get_tick(broker_symbol)
    if tick is None:
        log. warning(f"[{symbol}] Cannot get current tick price")
        return None
    
    current_price = tick.bid if direction == "bullish" else tick.ask
    
    # === STEP 7:  ENTRY PROXIMITY CHECK (This is what backtest does implicitly) ===
    entry_distance = abs(current_price - entry)
    entry_distance_r = entry_distance / risk
    
    if entry_distance_r > FTMO_CONFIG.max_entry_distance_r:
        log.info(f"[{symbol}] Entry too far:  {entry:. 5f} is {entry_distance_r:.2f}R from current {current_price:.5f} (max: {FTMO_CONFIG.max_entry_distance_r}R)")
        return None
    
    log.info(f"[{symbol}] Entry proximity OK: {entry_distance_r:.2f}R from current price")
    
    # === STEP 8: VALIDATE STOP LOSS ===
    pip_size = get_pip_size(symbol)
    sl_pips = abs(entry - sl) / pip_size
    
    # Check minimum SL
    if sl_pips < FTMO_CONFIG. min_sl_pips: 
        log.info(f"[{symbol}] SL too tight: {sl_pips:.1f} pips (min: {FTMO_CONFIG.min_sl_pips})")
        # Adjust SL to minimum
        if direction == "bullish":
            sl = entry - (FTMO_CONFIG.min_sl_pips * pip_size)
        else:
            sl = entry + (FTMO_CONFIG.min_sl_pips * pip_size)
        risk = abs(entry - sl)
        sl_pips = FTMO_CONFIG.min_sl_pips
        log.info(f"[{symbol}] SL adjusted to minimum: {sl:. 5f} ({sl_pips:.1f} pips)")
    
    # Check maximum SL
    if sl_pips > FTMO_CONFIG.max_sl_pips:
        log.info(f"[{symbol}] SL too wide: {sl_pips:.1f} pips (max: {FTMO_CONFIG.max_sl_pips}) - skipping")
        return None
    
    # === STEP 9: VALIDATE ATR-BASED SL ===
    atr = self._calculate_atr(daily_candles, period=14)
    if atr > 0:
        sl_atr_ratio = abs(entry - sl) / atr
        
        if sl_atr_ratio < FTMO_CONFIG.min_sl_atr_ratio: 
            log.info(f"[{symbol}] SL too tight in ATR terms: {sl_atr_ratio:.2f} ATR (min: {FTMO_CONFIG.min_sl_atr_ratio})")
            # Adjust SL
            if direction == "bullish": 
                sl = entry - (atr * FTMO_CONFIG.min_sl_atr_ratio)
            else:
                sl = entry + (atr * FTMO_CONFIG.min_sl_atr_ratio)
            risk = abs(entry - sl)
            log.info(f"[{symbol}] SL adjusted to {FTMO_CONFIG.min_sl_atr_ratio} ATR: {sl:.5f}")
        
        elif sl_atr_ratio > FTMO_CONFIG.max_sl_atr_ratio: 
            log.info(f"[{symbol}] SL too wide in ATR terms: {sl_atr_ratio:.2f} ATR (max: {FTMO_CONFIG.max_sl_atr_ratio}) - skipping")
            return None
    
    # === STEP 10: RECALCULATE TPs BASED ON VALIDATED RISK ===
    risk = abs(entry - sl)
    if direction == "bullish":
        tp1 = entry + (risk * FTMO_CONFIG. tp1_r_multiple)
        tp2 = entry + (risk * FTMO_CONFIG. tp2_r_multiple)
        tp3 = entry + (risk * FTMO_CONFIG. tp3_r_multiple)
    else:
        tp1 = entry - (risk * FTMO_CONFIG.tp1_r_multiple)
        tp2 = entry - (risk * FTMO_CONFIG.tp2_r_multiple)
        tp3 = entry - (risk * FTMO_CONFIG.tp3_r_multiple)
    
    # === STEP 11: FINAL VALIDATION ===
    # Check that entry is between current price and SL (not already past SL)
    if direction == "bullish":
        if current_price <= sl:
            log.warning(f"[{symbol}] Current price {current_price:.5f} already below SL {sl:.5f} - skipping")
            return None
    else:
        if current_price >= sl:
            log.warning(f"[{symbol}] Current price {current_price:.5f} already above SL {sl:.5f} - skipping")
            return None
    
    log.info(f"[{symbol}] ✓ ACTIVE SIGNAL VALIDATED!")
    log.info(f"  Direction: {direction.upper()}")
    log.info(f"  Confluence: {confluence_score}/7")
    log.info(f"  Current Price: {current_price:.5f}")
    log.info(f"  Entry: {entry:.5f} ({entry_distance_r:.2f}R away)")
    log.info(f"  SL: {sl:. 5f} ({sl_pips:.1f} pips)")
    log.info(f"  TP1: {tp1:.5f} (1R)")
    log.info(f"  TP2: {tp2:.5f} (2R)")
    log.info(f"  TP3: {tp3:.5f} (3R)")
    
    return {
        "symbol": symbol,
        "broker_symbol": broker_symbol,
        "direction": direction,
        "confluence":  confluence_score,
        "quality_factors": quality_factors,
        "current_price": current_price,
        "entry": entry,
        "stop_loss": sl,
        "tp1": tp1,
        "tp2": tp2,
        "tp3": tp3,
        "entry_distance_r": entry_distance_r,
        "sl_pips":  sl_pips,
        "flags": flags,
        "notes":  notes,
    }
```

### STEP 3: Update `main_live_bot.py` - Replace the `place_setup_order` method entirely

```python
def place_setup_order(self, setup:  Dict) -> bool:
    """
    Place order for a validated setup.
    
    FTMO 10K OPTIMIZED:
    - Uses market order when price is at entry (like backtest instant fill)
    - Uses pending order when price is near but not at entry
    - Validates all risk limits before placing
    - Calculates proper lot size for 10K account
    """
    from ftmo_config import FTMO_CONFIG, get_pip_size
    
    symbol = setup["symbol"]
    broker_symbol = setup["broker_symbol"]
    direction = setup["direction"]
    current_price = setup["current_price"]
    entry = setup["entry"]
    sl = setup["stop_loss"]
    tp1 = setup["tp1"]
    tp2 = setup. get("tp2")
    tp3 = setup. get("tp3")
    confluence = setup["confluence"]
    quality_factors = setup["quality_factors"]
    entry_distance_r = setup["entry_distance_r"]
    
    # === STEP 1: Check if we already have setup for this symbol ===
    if symbol in self.pending_setups:
        existing = self.pending_setups[symbol]
        if existing.status == "pending": 
            log.info(f"[{symbol}] Already have pending setup at {existing.entry_price:.5f}, skipping")
            return False
    
    # === STEP 2: Get account snapshot and determine risk mode ===
    if CHALLENGE_MODE and self.challenge_manager:
        snapshot = self.challenge_manager.get_account_snapshot()
        if snapshot is None:
            log.error(f"[{symbol}] Cannot get account snapshot")
            return False
        
        # Calculate current daily loss and total DD
        daily_loss_pct = abs(snapshot.daily_pnl_pct) if snapshot.daily_pnl_pct < 0 else 0
        total_dd_pct = snapshot.total_drawdown_pct
        profit_pct = (snapshot.equity - self.challenge_manager.initial_balance) / self.challenge_manager. initial_balance * 100
        
        # Check if trading is halted
        if daily_loss_pct >= FTMO_CONFIG.daily_loss_halt_pct:
            log. warning(f"[{symbol}] Trading halted:  daily loss {daily_loss_pct:.1f}% >= {FTMO_CONFIG.daily_loss_halt_pct}%")
            return False
        
        if total_dd_pct >= FTMO_CONFIG.total_dd_halt_pct:
            log.warning(f"[{symbol}] Trading halted: total DD {total_dd_pct:. 1f}% >= {FTMO_CONFIG.total_dd_halt_pct}%")
            return False
        
        # Check max concurrent trades
        max_trades = FTMO_CONFIG.get_max_trades(profit_pct)
        if snapshot.open_positions >= max_trades:
            log. info(f"[{symbol}] Max trades reached: {snapshot.open_positions}/{max_trades}")
            return False
        
        # Check cumulative risk
        if snapshot.total_risk_pct >= FTMO_CONFIG.max_cumulative_risk_pct: 
            log.info(f"[{symbol}] Max cumulative risk reached: {snapshot. total_risk_pct:.1f}%/{FTMO_CONFIG.max_cumulative_risk_pct}%")
            return False
        
        # Get adjusted risk percentage
        risk_pct = FTMO_CONFIG.get_risk_pct(daily_loss_pct, total_dd_pct)
        
        if risk_pct <= 0:
            log.warning(f"[{symbol}] Risk percentage is 0 - trading halted")
            return False
        
        # Calculate lot size
        risk_usd = snapshot.balance * (risk_pct / 100)
        risk_pips = abs(entry - sl) / get_pip_size(symbol)
        
        # Get pip value for this symbol
        from tradr.risk. position_sizing import get_pip_value
        pip_value = get_pip_value(broker_symbol, entry)
        
        if pip_value <= 0 or risk_pips <= 0:
            log.warning(f"[{symbol}] Cannot calculate lot size: pip_value={pip_value}, risk_pips={risk_pips}")
            return False
        
        lot_size = risk_usd / (risk_pips * pip_value)
        
        # Round to broker specifications
        symbol_info = self.mt5.get_symbol_info(broker_symbol)
        if symbol_info: 
            lot_step = symbol_info.volume_step if hasattr(symbol_info, 'volume_step') else 0.01
            min_lot = symbol_info.volume_min if hasattr(symbol_info, 'volume_min') else 0.01
            max_lot = symbol_info.volume_max if hasattr(symbol_info, 'volume_max') else 100. 0
            
            lot_size = max(min_lot, round(lot_size / lot_step) * lot_step)
            lot_size = min(lot_size, max_lot)
        else:
            lot_size = round(lot_size, 2)
            lot_size = max(0.01, lot_size)
        
        log.info(f"[{symbol}] Risk calculation:")
        log.info(f"  Balance: ${snapshot.balance:.2f}")
        log.info(f"  Risk %: {risk_pct:.2f}% (daily loss: {daily_loss_pct:.1f}%, DD: {total_dd_pct:.1f}%)")
        log.info(f"  Risk $: ${risk_usd:. 2f}")
        log.info(f"  Lot size:  {lot_size}")
        
        # === STEP 3: Final risk validation ===
        # Simulate if this trade would breach limits
        simulated_risk = snapshot.total_risk_usd + risk_usd
        simulated_risk_pct = (simulated_risk / snapshot.balance) * 100
        
        if simulated_risk_pct > FTMO_CONFIG.max_cumulative_risk_pct: 
            available_risk = (FTMO_CONFIG.max_cumulative_risk_pct / 100 * snapshot.balance) - snapshot.total_risk_usd
            if available_risk <= 0:
                log.warning(f"[{symbol}] No risk budget available")
                return False
            
            # Reduce lot size to fit available risk
            reduction = available_risk / risk_usd
            lot_size = round(lot_size * reduction * 0.9, 2)  # 10% buffer
            lot_size = max(0.01, lot_size)
            log.info(f"[{symbol}] Lot reduced to {lot_size} to stay within cumulative risk limit")
        
        # Simulate daily loss if SL hit
        simulated_daily_loss = abs(snapshot.daily_pnl) + risk_usd if snapshot.daily_pnl < 0 else risk_usd
        simulated_daily_loss_pct = (simulated_daily_loss / self.challenge_manager.day_start_balance) * 100
        
        if simulated_daily_loss_pct >= FTMO_CONFIG.max_daily_loss_pct: 
            log.warning(f"[{symbol}] Would breach daily loss:  simulated {simulated_daily_loss_pct:.1f}% >= {FTMO_CONFIG.max_daily_loss_pct}%")
            return False
        
    else:
        # Non-challenge mode - use standard risk manager
        risk_check = self.risk_manager.check_trade(
            symbol=broker_symbol,
            direction=direction,
            entry_price=entry,
            stop_loss_price=sl,
        )
        
        if not risk_check. allowed:
            log.warning(f"[{symbol}] Trade blocked by risk manager: {risk_check.reason}")
            return False
        
        lot_size = risk_check.adjusted_lot
    
    # === STEP 4:  Determine order type based on entry distance ===
    if entry_distance_r <= FTMO_CONFIG.immediate_entry_r:
        # Price is AT entry level - use market order (like backtest instant fill)
        order_type = "MARKET"
        log.info(f"[{symbol}] Price at entry ({entry_distance_r:.2f}R) - using MARKET ORDER")
        
        result = self.mt5.place_market_order(
            symbol=broker_symbol,
            direction=direction,
            volume=lot_size,
            sl=sl,
            tp=tp1,
        )
    else:
        # Price is near entry - use pending order
        order_type = "PENDING"
        log.info(f"[{symbol}] Price {entry_distance_r:.2f}R from entry - using PENDING ORDER")
        
        result = self.mt5.place_pending_order(
            symbol=broker_symbol,
            direction=direction,
            volume=lot_size,
            entry_price=entry,
            sl=sl,
            tp=tp1,
            expiration_hours=FTMO_CONFIG.pending_order_expiry_hours,
        )
    
    if not result. success:
        log.error(f"[{symbol}] {order_type} order FAILED: {result.error}")
        return False
    
    log.info(f"[{symbol}] ✓ {order_type} ORDER PLACED!")
    log.info(f"  Order ID: {result.order_id}")
    log.info(f"  Price: {result.price:.5f}")
    log.info(f"  Volume: {result.volume}")
    
    # === STEP 5: Track the setup ===
    pending_setup = PendingSetup(
        symbol=symbol,
        direction=direction,
        entry_price=entry if order_type == "PENDING" else result.price,
        stop_loss=sl,
        tp1=tp1,
        tp2=tp2,
        tp3=tp3,
        confluence=confluence,
        quality_factors=quality_factors,
        created_at=datetime.now(timezone.utc).isoformat(),
        order_ticket=result.order_id,
        status="pending" if order_type == "PENDING" else "filled",
        lot_size=lot_size,
    )
    
    self.pending_setups[symbol] = pending_setup
    self._save_pending_setups()
    
    # Record trade if filled immediately
    if order_type == "MARKET":
        self.risk_manager.record_trade_open(
            symbol=broker_symbol,
            direction=direction,
            entry_price=result.price,
            stop_loss=sl,
            lot_size=lot_size,
            order_id=result.order_id,
        )
    
    return True
```

### STEP 4: Add helper methods to `main_live_bot.py`

Add these methods to the `LiveTradingBot` class:

```python
def _calculate_atr(self, candles: List[Dict], period: int = 14) -> float:
    """Calculate Average True Range."""
    if not candles or len(candles) < period + 1:
        return 0.0
    
    true_ranges = []
    for i in range(1, len(candles)):
        high = candles[i]["high"]
        low = candles[i]["low"]
        prev_close = candles[i-1]["close"]
        
        tr = max(
            high - low,
            abs(high - prev_close),
            abs(low - prev_close)
        )
        true_ranges.append(tr)
    
    if len(true_ranges) >= period:
        return sum(true_ranges[-period:]) / period
    return sum(true_ranges) / len(true_ranges) if true_ranges else 0.0
```

### STEP 5: Add `place_market_order` to `tradr/mt5/client.py`

Add this method to the `MT5Client` class:

```python
def place_market_order(
    self,
    symbol: str,
    direction: str,
    volume:  float,
    sl: float,
    tp: float,
) -> TradeResult:
    """
    Place immediate market order.
    Matches backtest behavior of instant fill when price is at entry level.
    """
    if not self.connected:
        return TradeResult(success=False, error="Not connected")
    
    mt5 = self._import_mt5()
    
    # Get current tick
    tick = mt5.symbol_info_tick(symbol)
    if tick is None:
        return TradeResult(success=False, error=f"Cannot get tick for {symbol}")
    
    # Get symbol info for normalization
    symbol_info = mt5.symbol_info(symbol)
    if symbol_info is None:
        return TradeResult(success=False, error=f"Cannot get symbol info for {symbol}")
    
    # Normalize volume
    lot_step = symbol_info.volume_step
    min_lot = symbol_info.volume_min
    max_lot = symbol_info.volume_max
    
    volume = max(min_lot, round(volume / lot_step) * lot_step)
    volume = min(volume, max_lot)
    
    # Determine order type and price
    if direction. lower() == "bullish":
        order_type = mt5.ORDER_TYPE_BUY
        price = tick.ask
    else:
        order_type = mt5.ORDER_TYPE_SELL
        price = tick.bid
    
    # Normalize SL/TP
    digits = symbol_info.digits
    sl = round(sl, digits) if sl else 0
    tp = round(tp, digits) if tp else 0
    
    # Build request
    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": volume,
        "type": order_type,
        "price": price,
        "sl": sl,
        "tp":  tp,
        "magic": self. MAGIC_NUMBER,
        "comment": "FTMO_BOT",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_IOC,
    }
    
    # Send order
    result = mt5.order_send(request)
    
    if result is None:
        return TradeResult(success=False, error="order_send returned None")
    
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        return TradeResult(
            success=False,
            error=f"Order failed: {result.retcode} - {result. comment}",
        )
    
    return TradeResult(
        success=True,
        order_id=result.order,
        price=result.price,
        volume=result.volume,
    )
```

### STEP 6: Update `challenge_risk_manager.py` - Update ChallengeConfig defaults

Replace the `ChallengeConfig` dataclass: 

```python
@dataclass
class ChallengeConfig:
    """FTMO 10K Challenge configuration."""
    enabled: bool = True
    phase: int = 1
    
    # Account
    account_size: float = 10000.0
    phase1_target_pct: float = 10.0
    phase2_target_pct: float = 5.0
    max_daily_loss_pct:  float = 5.0
    max_total_drawdown_pct: float = 10.0
    
    # Risk per trade (conservative for 10K)
    max_risk_per_trade_pct: float = 0.75
    max_cumulative_risk_pct: float = 2.5
    max_concurrent_trades: int = 4
    max_pending_orders: int = 5
    
    # Partial takes (lock profits fast)
    tp1_close_pct: float = 0.40
    tp2_close_pct: float = 0.35
    tp3_close_pct: float = 0.25
    
    # Safety thresholds (stop BEFORE breach)
    daily_loss_warning_pct: float = 2.5
    daily_loss_reduce_pct: float = 3.5
    daily_loss_halt_pct:  float = 4.2
    total_dd_warning_pct:  float = 5.0
    total_dd_emergency_pct: float = 7.0
    
    # Protection
    protection_loop_interval_sec: float = 20.0
    pending_order_max_age_hours: float = 6.0
    
    # Ultra-safe mode
    profit_ultra_safe_threshold_pct: float = 8.0
    ultra_safe_risk_pct: float = 0.25
```

## VERIFICATION CHECKLIST

After implementing all changes, verify: 

1. Run a scan and check logs show: 
   - "Entry proximity OK:  X. XXR from current price" (should be <= 1. 0R)
   - "MARKET ORDER" when within 0.15R, "PENDING ORDER" when 0.15-1.0R
   - Lot sizes appropriate for 10K (typically 0.01-0.15)

2. Check risk limits: 
   - Max 0.75% per trade = $75 risk
   - Max 2.5% cumulative = $250 total open risk
   - Max 4 concurrent trades

3. Check safety thresholds:
   - Warning at 2.5% daily loss ($250)
   - Reduced risk at 3.5% daily loss ($350)
   - Trading halt at 4.2% daily loss ($420)

4. Entries should now match backtest behavior: 
   - Only signals where price is within 1R of calculated entry
   - Instant fill (market order) when price is at entry level
   - Proper SL validation (8-100 pips, 0.4-2.0 ATR)

This will make the live bot take the same trades as the backtest while staying 100% FTMO compliant. 
```

---

This prompt is complete and copy-paste ready. It includes all the code changes needed to: 

1. **Match backtest entries** - Only take trades where price is within 1R of entry
2. **Use correct order types** - Market order when at entry, pending order when near
3. **FTMO 10K compliance** - Conservative risk settings, safety buffers before limits
4. **Proper SL validation** - Ensure SLs are appropriate (not too tight/wide)
5. **Smart position sizing** - Adaptive risk based on current drawdown